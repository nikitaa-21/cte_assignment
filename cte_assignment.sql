 -- CTE assignment

use mavenmovies;

 -- Identify a table in the Sakila database that violates 1NF 
  -- Explain how you would normalize it to achieve 1NF
  
  select*from actor_award; 
   -- Tables in sakila database that violates 1NF are actor_award , film table.
-- In actor_award table multivalued attributes are present in awards column. In order to normalise it 
-- to 1NF we should have to make different columns of different award names.
-- Similarly in Film Table under special_features column aslo multivalued attributes are present and 
-- in order to normalise it to 1NF we should have to make different columns of different special features.

 -- Choose a table in Sakila and describe how you would determine whether it is in 2NF
 -- If it violates 2NF, explain the steps to normalize it
 
 SELECT * FROM payment;
-- In this example, the payment table includes columns such as customer_id, staff_id, and rental_id.
-- To determine whether the table is in Second Normal Form (2NF) , we need to check for partial dependencies.
 
--  Identify if any attributes depend on only a part of the primary key.
 -- In this case, 'amount' depends only on "rental_id", and "payment_date" depends on "payment_id".
 -- These dependencies violates 2NF.
 
  -- Steps to Normalize :
-- 1) Identify the redundancy we want to remove data_repetation 
-- 2) Establish relationships between the tables.

-- Identify a table in Sakila that violates 3NF
-- Describe the transitive dependencies present and outline the steps to normalize the table to 3NF

 -- Let's consider the film table in the Sakila database and check if it violates the Third Normal Form (3NF). 
describe film;
-- Now, let's assume that replacement_cost depends on length (film duration), and both length and replacement_cost depend on the film_id.
--  This would represent a transitive dependency.

-- 1. Identify Transitive Dependency: replacement_cost depends on length.
-- #  length and replacement_cost both depend on film_id
 -- # This creates a transitive dependency: film_id -> length -> replacement_cost.
 
 -- 2. Normalize to 3NF: Create a new table (film_details) with columns related to the transitive dependency.
 -- #  Move the dependent columns (length, replacement_cost) to the new table.
 -- # Include the determinant (film_id) in both the original and new tables.


-- New table for transitive dependency
CREATE TABLE film_details (
    film_id smallint unsigned PRIMARY KEY,
    length smallint unsigned,
    replacement_cost DECIMAL(5,2),
    FOREIGN KEY (film_id) REFERENCES film(film_id)
);
-- By creating the film_details table and moving the columns with the transitive dependency, we ensure that the replacement_cost is now
-- directly dependent on the primary key (film_id), meeting the requirements of the Third Normal Form (3NF).

-- Write a query using a CTE to retrieve the distinct list of actor names and the number of films they have
-- acted in from the actor and film_actor tables

WITH ActorFilmCounts AS (
    SELECT
        a.actor_id,
        CONCAT(a.first_name, ' ', a.last_name) AS actor_name,
        COUNT(fa.film_id) AS film_count
    FROM
        actor a
    JOIN
        film_actor fa ON a.actor_id = fa.actor_id
    GROUP BY
        a.actor_id, actor_name
)

SELECT
    actor_id,
    actor_name,
    film_count
FROM
    ActorFilmCounts;
    
-- Use a recursive CTE to generate a hierarchical list of categories and their subcategories from the
-- category table in Sakila

WITH RECURSIVE CategoryHierarchy AS (
    SELECT category_id,name AS category_name,NULL AS parent_category_id,0 AS level
    FROM category WHERE parent_category_id IS NULL
    UNION ALL
    SELECT 
        c.category_id,c.name AS category_name,ch.category_id AS parent_category_id,ch.level + 1 AS level
    FROM category c JOIN CategoryHierarchy ch ON c.parent_category_id = ch.category_id
)
SELECT 
    category_id,
    category_name,
    parent_category_id,
    level
FROM 
    CategoryHierarchy
ORDER BY 
    level, category_id;
    
-- Create a CTE that combines information from the film and language tables to display the film title, language
-- name, and rental rate

WITH FilmLanguageInfo AS (
  SELECT
    f.title AS film_title,
    l.name AS language_name,
    f.rental_rate
  FROM
    film f
    JOIN language l ON f.language_id = l.language_id
)

SELECT
  film_title,
  language_name,
  rental_rate
FROM
  FilmLanguageInfo;
  
-- Write a query using a CTE to find the total revenue generated by each customer (sum of payments) from
-- the customer and payment tables

with totalrevenue as (
select c.customer_id, concat(first_name," ",last_name) as customer_name , sum(amount) as totalrevenue from customer c
join payment on payment.customer_id = c.customer_id group by c.customer_id
)
select customer_id, customer_name, totalrevenue from totalrevenue;

-- Utilize a CTE with a window function to rank films based on their rental duration from the table

select * from film;
with filmRanking as (
select film_id, rental_duration ,rank() 
over(order by rental_duration desc ) as film_Rank from film
)
select film_id, rental_duration , film_Rank from  filmRanking;

-- Create a CTE to list customers who have made more than two rentals, and then join this CTE with the
-- customer table to retrieve additional customer details

with customerDetails as (
select c.customer_id, count(rental_id) as rentals from customer c
join rental r on r.customer_id = c.customer_id group by c.customer_id having rentals > 2
)
select * from customerDetails cd join customer ct on ct.customer_id = cd.customer_id;

-- Write a query using a CTE to find the total number of rentals made each month, considering the
-- rental date from the rental table

with totalRentalMonths as (
select  monthname(rental_date) as month_name, count(rental_id) as rental from rental
group by month_name
)
select month_name , rental from totalRentalMonths;

-- Use a CTE to pivot the data from the payment table to display the total payments made by each customer in
-- separate columns for different payment methods

with totalPayments as (
select c.customer_id, first_name, last_name, SUM(amount) total_payment, 
'Unknown' AS payment_method from customer c 
join payment on payment.customer_id = c.customer_id group by c.customer_id
)
select customer_id, first_name, last_name, total_payment, payment_method from totalPayments;
-- payment methods data is not available in DB
    
-- Create a CTE to generate a report showing pairs of actors who have appeared in the same film together,
-- using the film_actor table

with actor_pairs as(select 
fa.actor_id as actor_1, ft.actor_id as actor_2,
title 
from film_actor fa
join  film_actor ft on fa.film_id = ft.film_id and fa.actor_id < ft.actor_id
join film f on fa.film_id = f.film_id
)
select actor_1,actor_2,title from actor_pairs;

-- Implement a recursive CTE to find all employees in the staff table who report to a specific manager,
-- considering the  reports_t0 column.

WITH RECURSIVE employeeReports AS (
  SELECT staff_id, first_name,last_name,'unknown' AS reports_to
   FROM staff WHERE staff_id = 'manager_id'  -- Replace 'manager_id' with the ID of the specific manager
   UNION ALL
   SELECT s.staff_id,s.first_name,s.last_name,e.reports_to
   FROM staff s JOIN employeeReports e ON s.staff_id = e.staff_id
 )
 SELECT staff_id,first_name,last_name,reports_to
 FROM employeeReports;
-- NO MANGER DATA AND REPORTS TO DATA AVAILABEL

    
 